# 分析
题目要求在最坏情况下的比较次数为~2lgN。因此不能采用遍历的做法。

注意，题目里是要求找到一个局部最小值，而非找到全部。

而且题目里没有说明的是，对于数组两端的值，即a[0]和a[a.length -1]，它们只需要比紧邻的元素小就行了。

## 何时一个数组里没有局部最小值
由于数组里的所有整数都不同。而两端的元素只需要比紧邻元素小。因此从a[0]出发，a[1]必须小于a[0]，否则a[0]就是局部最小值。
a[2]必须小于a[1]否则a[1]就是局部最小值。这样下去a[n]一定需要小于a[n-1]，但是由于数组是有限的，所以a[a.length-1]如果小于前一元素它就是局部最小值，如果大于前一元素，它的前一个元素就是局部最小值。

## divide and conquer

因此，任何一个元素不同的数组必有局部最小值。那么我们就可以试图使用divide and conquer方法，类似于二分查找。

那么，比较a[mid]和a[mid-1]、a[mid+1]的关系。

* 如果a[mid]是局部最小值，那么得到最终答案。
* 此时局部最小值肯定不是a[mid]。
    * 如果a[mid+1] > a[mid]，那么在a[mid] a[mid+1] ... a[a.length-1]这个数组中，a[mid]是局部最小值。我们无法保证在这半边的其它元素中仍然存在局部最小值，比如，接下来是一个递增序列。所以，如果a[mid]其中一个方向的紧邻元素大于a[mid]，那么这半边数组可能不存在局部最小值。
    * 如果a[mid+1] < a[mid]，那么在a[mid] a[mid+1] ... a[a.length-1]这个数组中，a[mid]肯定不是局部最小值。由于前边的结论：每个元素不同的数组必须局部最小值，那么这半边的数组必须存在局部最小值。
* 所以，如果a[mid-1] < a[mid]，问题就变成了在a[0 ... mid-1]中寻找局部最小值，否则在a[mid + 1 ... length-1]中寻找局部最小值。base case为a的长度为1，那么局部最小值就是a[0]，以及a的长度为2，那么局部最小值就是二者里较小的一个。